/* ========================================
 *
 * Copyright AIO Systems, 2018
 * Written by Novodes for AIO Systems
 * All Rights Reserved
 * UNPUBLISHED, LICENSED SOFTWARE.
 *
 * CONFIDENTIAL AND PROPRIETARY INFORMATION
 * WHICH IS THE PROPERTY OF AIO Systems.
 *
 * ========================================
*/
/**
  ******************************************************************************
  * @file           : rtc.c
  * @brief          : This file contains functions related to the internal RTC module
											of the MCU. RTC - Real Time Clock. 
  ******************************************************************************
**/

/* [] BEGINNING OF FILE */

/* Includes ------------------------------------------------------------------*/
#include "rtc.h"
#include "stm32l0xx_hal_rtc.h"

/* Private typedef -----------------------------------------------------------*/

/* Private define ------------------------------------------------------------*/

#define MAX_RTC_ALARM_PERIOD 23*3600+59*60+59	// [seconds] the hours, minutes and seconds variables of the alarm struct handle are all limited to 23, 59 and 59 respectively (see stm32l0xx_hal_rtc.h)

/* Private macro -------------------------------------------------------------*/

/* Private variables ---------------------------------------------------------*/
 
volatile RTC_AlarmTypeDef alarm_def_A; // an RTC_AlarmTypeDef variable to hold all the definitions of the alarm structure generated by the cube. Unlike other handles that are global and may be exported out of the main.c, the alarm handle is locally generated within the function MX_RTC_Init, and therefore it may not be exported easily. Instead we use the function Set_RTCAlarmTypeDef() 
volatile RTC_AlarmTypeDef alarm_def_B; // an RTC_AlarmTypeDef variable to hold all the definitions of the alarm structure generated by the cube. Unlike other handles that are global and may be exported out of the main.c, the alarm handle is locally generated within the function MX_RTC_Init, and therefore it may not be exported easily. Instead we use the function Set_RTCAlarmTypeDef() 

volatile uint8_t RTC_WakeUpInterrupt_Flag = FALSE;		// a flag indicating whether the RTC wakeup interrupt occured. 
/* Private function prototypes -----------------------------------------------*/

/* Exported functions ---------------------------------------------------------*/

/**
  * @brief  This function sets the duration for the wakeup up timer of the rtc.
						The wakeup timer is used to wake up the MCU from low power modes. 
  * @param  uint32_t period - the period of time [seconds] in seconds after which to wake up the MCU
  * @retval None
  */
void Set_RTC_Wakeup(uint32_t period)
{
	uint32_t clk_src, rtc_clk_freq;
	uint32_t WakeUpCounter, WakeUpTimeBase;
	
	 /* ## Setting the Wake up time ############################################*/
    /*  RTC Wakeup Interrupt Generation:
      Wakeup Time Base = (RTC_WAKEUPCLOCK_RTCCLK_DIV /(LSE or LSI))
      Wakeup Time = Wakeup Time Base * WakeUpCounter 
      = (RTC_WAKEUPCLOCK_RTCCLK_DIV /(LSE or LSI)) * WakeUpCounter
        ==> WakeUpCounter = Wakeup Time / Wakeup Time Base
    
			Example: 
      To configure the wake up timer to 4s the WakeUpCounter is set to 0x2616 in case of LSI CLK:
      RTC_WAKEUPCLOCK_RTCCLK_DIV = RTCCLK_Div16 = 16 
      Wakeup Time Base = 16 /(~39.000KHz) = ~0,488 ms
      Wakeup Time = ~4s = 0,488ms  * WakeUpCounter
        ==> WakeUpCounter = ~4s/0,488ms = 9750 = 0x2616 
	
			To configure the wake up timer to 4s the WakeUpCounter is set to 0x2004 in case of LSE CLK:
      RTC_WAKEUPCLOCK_RTCCLK_DIV = RTCCLK_Div16 = 16 
      Wakeup Time Base = 16 /(32.768KHz) = ~0,410 ms
      Wakeup Time = ~4s = 0,410ms  * WakeUpCounter
        ==> WakeUpCounter = ~4s/0,410ms = 8196 = 0x2004 */
	
	clk_src = __HAL_RCC_GET_RTC_SOURCE();
	switch(clk_src)
	{
		case RCC_RTCCLKSOURCE_NO_CLK:
			printf("Set_RTC_Wakeup() Error. No clock source selected for the RTC.\n\r");
			return;
		case RCC_RTCCLKSOURCE_LSE:
			rtc_clk_freq = LSE_FREQUENCY; // external oscillator LSE frequency
			break;
		case RCC_RTCCLKSOURCE_LSI:
			rtc_clk_freq = LSI_FREQUENCY;	// internal oscillator
			break;
		case RCC_RTCCLKSOURCE_HSE_DIVX:
			printf("Set_RTC_Wakeup() Error. Support for HSE Clock source for RTC has not been written yet.\n\r");	// it simply should be written.
			break;	
	}
	
	/*Add here more modularity to support various selections of the RTC Clock - not just RTC_WAKEUPCLOCK_RTCCLK_DIV16*/
	
	WakeUpTimeBase = (1000000*((uint32_t)16)) / rtc_clk_freq;	// assuming we are using RTC_WAKEUPCLOCK_RTCCLK_DIV16 for the wakeup clock
	WakeUpCounter = (1000000*period) / WakeUpTimeBase;	// based on the formula written above at the beginning of the function
	
  HAL_RTCEx_SetWakeUpTimer_IT(&hrtc, WakeUpCounter, RTC_WAKEUPCLOCK_RTCCLK_DIV16);
}

/**
  * @brief  This function disables the wakeup mechanism of the RTC
  * @param  None
  * @retval None
  */
void Disable_RTC_Wakeup(void)
{
	HAL_RTCEx_DeactivateWakeUpTimer(&hrtc);
}

/**
  * @brief  This function disables the wakeup mechanism of the RTC
  * @param  uint32_t period - the period of time [seconds] after which to set the alarm of the RTC
						uint32_t alarm - the alarm to disable (either RTC_ALARM_A or RTC_ALARM_B)
  * @retval None
  */
void Set_RTC_Alarm(uint32_t period, uint32_t alarm)
{
	/* ######################################
	
	21.08.2018
	FUNCTION HAS BEEN WRITTEN PROPERLY YET. WE NEED TO TAKE INTO ACCOUNT THE MAX PERIOD WE WANT TO ALLOW TO SET AN ALARM
  AND REMEMBER THAT IT NEEDS TO BE RELATIVE TO THE RTC CLOCK! THAT MEANS THAT IF THE CURRENT SECONDS IN THE RTC CLOCK
  ARE 59 SECONDS AND WE WANT TO MAKE AN ALARM FOR 1 MORE SECOND THEN WE WOULD NEED TO UPDATE THE ALARM SO THAT THE SECONDS
	WOULD BE ZERO AND THE MINUTES WOULD BE THE CURRENT RTC TIME MINUTES + 1. THIS REQUIRES MORE LOGIC SO RIGHT NOW THE 
	FUNCTION IS NOT READY AT ALL.
	
	#########################################*/
	RTC_AlarmTypeDef sAlarm;
	uint8_t	hours,minutes,seconds; 
	
	if(alarm == RTC_ALARM_A)
		sAlarm = alarm_def_A;
	else // alarm = RTC_ALARM_B
		sAlarm = alarm_def_B;
	
	if(period > MAX_RTC_ALARM_PERIOD)
		printf("Set_RTC_Alarm Error: Cannot set alarm because period is too big. Period = %d. MAX value possible is %d\n\r",period,MAX_RTC_ALARM_PERIOD);
	
	hours = period / 3600;	// 60 seconds * 60 minutes = 1 hour
	minutes = (period / 60) - (hours * 60);	// total minutes in the period minus the portion that is allocated to the hours
	seconds = (period / 3600) - (hours * 3600) - (minutes * 60);
	
	//Calculation of the time: 
	sAlarm.AlarmTime.Hours = hours;
  sAlarm.AlarmTime.Minutes = minutes;
  sAlarm.AlarmTime.Seconds = seconds;
  sAlarm.AlarmTime.SubSeconds = 0;

	
	HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BIN);
}

/**
  * @brief  This function disables an alarm of the RTC
  * @param  uint32_t alarm - the alarm to disable (either RTC_ALARM_A or RTC_ALARM_B)
  * @retval None
  */
void Disable_RTC_Alarm(uint32_t alarm)
{
	HAL_RTC_DeactivateAlarm(&hrtc,alarm);
}

/**
  * @brief  This function keeps the definitions of the RTC_AlarmTypeDefs defined in the main.c file.
						Unlike other handles that are global and may be exported out of the main.c, the alarm handle is 
						locally generated within the function MX_RTC_Init, and therefore it may not be exported easily by
						simply writing "extern" in main.h. 
						Instead we use this function Set_RTCAlarmTypeDef() which is called from the user code area within 
						the function MX_RTC_Init to preserve the definitions of the alarm typedef to be later used in the code
  * @param  RTC_AlarmTypeDef alarm - the alarm defenitions to preserve 
						uint32_t alarm - the alarm identifier - either RTC_ALARM_A or RTC_ALARM_B
  * @retval None
  */
void Set_RTCAlarmTypeDef(RTC_AlarmTypeDef exported_alarm, uint32_t alarm)
{
	if(alarm == RTC_ALARM_A) 
		alarm_def_A = exported_alarm; // assign the value of the alarm structure to the relevant global variable.
	else // alarm = RTC_ALARM_B
		alarm_def_B = exported_alarm; // assign the value of the alarm structure to the relevant global variable.
}

/**
  * @brief  Callback function for the RTC wakeup interrupt
  * @param  RTC_HandleTypeDef *hrtc - the handle of the rtc that caused the interrupt
  * @retval None
  */
void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc)
{
	RTC_WakeUpInterrupt_Flag = TRUE;
}

/**
  * @brief  Callback function for the RTC alarm A interrupt
  * @param  RTC_HandleTypeDef *hrtc - the handle of the rtc that caused the interrupt
  * @retval None
  */
void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
{
	; // add code here. 
}

/**
  * @brief  Callback function for the RTC alarm B interrupt
  * @param  RTC_HandleTypeDef *hrtc - the handle of the rtc that caused the interrupt
  * @retval None
  */
void HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef *hrtc)
{
	; // add code here. 
}

/************************ (C) COPYRIGHT AIO Systems *****END OF FILE****/
